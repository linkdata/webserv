
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>webserv: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/webserv/becomeuser_unix.go (100.0%)</option>
				
				<option value="file1">github.com/linkdata/webserv/config.go (100.0%)</option>
				
				<option value="file2">github.com/linkdata/webserv/errbecomeuser.go (100.0%)</option>
				
				<option value="file3">github.com/linkdata/webserv/listener.go (100.0%)</option>
				
				<option value="file4">github.com/linkdata/webserv/loadcert.go (100.0%)</option>
				
				<option value="file5">github.com/linkdata/webserv/usedatadir.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//go:build unix || linux

package webserv

import (
        "os"
        "os/user"
        "strconv"
        "syscall"
)

var (
        lookupUserFn = user.Lookup
        groupIDsFn   = func(u *user.User) ([]string, error) <span class="cov8" title="1">{ return u.GroupIds() }</span>
        geteuidFn    = os.Geteuid
        setgroupsFn  = syscall.Setgroups
        setgidFn     = syscall.Setgid
        setuidFn     = syscall.Setuid
        unsetenvFn   = os.Unsetenv
        setenvFn     = os.Setenv
)

func parseGroupIDs(groupIDs []string) (gids []int, err error) <span class="cov8" title="1">{
        gids = make([]int, 0, len(groupIDs))
        for i := 0; i &lt; len(groupIDs) &amp;&amp; err == nil; i++ </span><span class="cov8" title="1">{
                var gid int
                if gid, err = strconv.Atoi(groupIDs[i]); err == nil </span><span class="cov8" title="1">{
                        gids = append(gids, gid)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// BecomeUser switches to the given userName if not empty.
//
// It sets the GID, UID and changes the USER and HOME
// environment variables accordingly. It unsets XDG_CONFIG_HOME.
//
// Returns ErrBecomeUserNotImplemented if the current OS is not supported.
func BecomeUser(userName string) error <span class="cov8" title="1">{
        var err error
        if userName != "" </span><span class="cov8" title="1">{
                var u *user.User
                if u, err = lookupUserFn(userName); err == nil </span><span class="cov8" title="1">{
                        var uid, gid int
                        if uid, err = strconv.Atoi(u.Uid); err == nil </span><span class="cov8" title="1">{
                                if gid, err = strconv.Atoi(u.Gid); err == nil </span><span class="cov8" title="1">{
                                        if geteuidFn() == 0 </span><span class="cov8" title="1">{
                                                var groupIDs []string
                                                if groupIDs, err = groupIDsFn(u); err == nil </span><span class="cov8" title="1">{
                                                        var gids []int
                                                        if gids, err = parseGroupIDs(groupIDs); err == nil </span><span class="cov8" title="1">{
                                                                if len(gids) == 0 </span><span class="cov8" title="1">{
                                                                        gids = []int{gid}
                                                                }</span>
                                                                <span class="cov8" title="1">err = setgroupsFn(gids)</span>
                                                        }
                                                }
                                        }
                                        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                                                if err = setgidFn(gid); err == nil </span><span class="cov8" title="1">{
                                                        if err = setuidFn(uid); err == nil </span><span class="cov8" title="1">{
                                                                _ = unsetenvFn("XDG_CONFIG_HOME")
                                                                if err = setenvFn("HOME", u.HomeDir); err == nil </span><span class="cov8" title="1">{
                                                                        err = setenvFn("USER", u.Username)
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return newErrBecomeUser(userName, err)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package webserv

import (
        "context"
        "io/fs"
        "net"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"
)

var ShutdownTimeLimit = time.Second

type Config struct {
        Address              string      // optional specific address (and/or port) to listen on
        CertDir              string      // if set, directory to look for fullchain.pem and privkey.pem
        FullchainPem         string      // set to override filename for "fullchain.pem"
        PrivkeyPem           string      // set to override filename for "privkey.pem"
        User                 string      // if set, user to switch to after opening listening port
        DataDir              string      // if set, create this directory, if unset will be filled in after Listen
        DefaultDataDirSuffix string      // if set and DataDir is not set, set DataDir to the user's default data dir plus this suffix
        DataDirMode          fs.FileMode // if nonzero, create DataDir if it does not exist using this mode
        ListenURL            string      // if set, the external URL clients can reach us at. If unset, Listen may fill this in (e.g. "https://localhost:8443"), even when Listen later returns an error after binding.
        Logger               Logger      // logger to use, if nil logs nothing
}

func (cfg *Config) logInfo(msg string, keyValuePairs ...any) <span class="cov8" title="1">{
        if cfg.Logger != nil &amp;&amp; len(keyValuePairs) &gt; 1 </span><span class="cov8" title="1">{
                s, ok := keyValuePairs[1].(string)
                if !ok || s != "" </span><span class="cov8" title="1">{
                        cfg.Logger.Info("webserv: "+msg, keyValuePairs...)
                }</span>
        }
}

// Listen performs initial setup for a simple web server and returns a
// net.Listener if successful.
//
// First it loads certificates if cfg.CertDir is set, and then starts a net.Listener
// (TLS or normal). The listener will default to all addresses and standard port
// depending on privileges and if a certificate was loaded or not.
//
// If cfg.Address was set, any address or port given there overrides these defaults.
//
// If cfg.User is set it then switches to that user and the users primary group.
// Note that this is not supported on Windows.
//
// If cfg.DataDir or cfg.DefaultDataDirSuffix is set, calculates the absolute
// data directory path and sets cfg.DataDir. If cfg.DataDirMode is nonzero, the
// directory will be created if necessary.
//
// On return, cfg.CertDir and cfg.DataDir will be absolute paths or be empty.
// If cfg.ListenURL was empty it may be set to a best-guess printable and connectable
// URL like "http://localhost:80" as soon as the socket is opened.
// Therefore cfg.ListenURL can be non-empty even if Listen returns an error from a
// later step, such as user switching or data directory setup.
func (cfg *Config) Listen() (l net.Listener, err error) <span class="cov8" title="1">{
        if l, cfg.ListenURL, cfg.CertDir, err = Listener(cfg.Address, cfg.CertDir, cfg.FullchainPem, cfg.PrivkeyPem, cfg.ListenURL); err == nil </span><span class="cov8" title="1">{
                cfg.logInfo("loaded certificates", "dir", cfg.CertDir)
                if err = BecomeUser(cfg.User); err == nil </span><span class="cov8" title="1">{
                        cfg.logInfo("user switched", "user", cfg.User)
                        if cfg.DataDir, err = DefaultDataDir(cfg.DataDir, cfg.DefaultDataDirSuffix); err == nil </span><span class="cov8" title="1">{
                                if cfg.DataDir, err = UseDataDir(cfg.DataDir, cfg.DataDirMode); err == nil </span><span class="cov8" title="1">{
                                        cfg.logInfo("data directory", "dir", cfg.DataDir)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                cfg.DataDir = ""
                if l != nil </span><span class="cov8" title="1">{
                        _ = l.Close()
                        l = nil
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// ServeWith sets up a signal handler to catch SIGINT and SIGTERM and then calls srv.Serve(l).
// If ctx is canceled, the server will be shut down and this function returns with ctx.Err().
//
// Returns nil if the server started successfully and then cleanly shut down.
//
// Panics if any of the arguments are nil.
func (cfg *Config) ServeWith(ctx context.Context, srv *http.Server, l net.Listener) (err error) <span class="cov8" title="1">{
        serveErr := make(chan error, 1)
        sigCtx, stop := signal.NotifyContext(ctx, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
        defer stop()
        cfg.logInfo("listening on", "address", l.Addr(), "url", cfg.ListenURL)
        go func() </span><span class="cov8" title="1">{
                serveErr &lt;- srv.Serve(l)
        }</span>()
        <span class="cov8" title="1">select </span>{
        case err = &lt;-serveErr:<span class="cov8" title="1"></span>
        case &lt;-sigCtx.Done():<span class="cov8" title="1">
                reason := "interrupted"
                if err = ctx.Err(); err != nil </span><span class="cov8" title="1">{
                        reason = err.Error()
                }</span> else<span class="cov8" title="1"> {
                        if cause := context.Cause(sigCtx); cause != nil </span><span class="cov8" title="1">{
                                reason = cause.Error()
                        }</span>
                }
                <span class="cov8" title="1">cfg.logInfo("stopped", "reason", reason)
                shutdownCtx, shutdownCancel := context.WithTimeout(ctx, ShutdownTimeLimit)
                shutdownErr := srv.Shutdown(shutdownCtx)
                shutdownCancel()
                serveExitErr := &lt;-serveErr
                if err == nil </span><span class="cov8" title="1">{
                        if shutdownErr != nil </span><span class="cov8" title="1">{
                                err = shutdownErr
                        }</span> else<span class="cov8" title="1"> {
                                err = serveExitErr
                        }</span>
                }
        }
        <span class="cov8" title="1">if err == http.ErrServerClosed </span><span class="cov8" title="1">{
                err = nil
        }</span>
        <span class="cov8" title="1">return err</span>
}

// Serve creates a http.Server with reasonable defaults and calls ServeWith.
func (cfg *Config) Serve(ctx context.Context, l net.Listener, handler http.Handler) error <span class="cov8" title="1">{
        srv := &amp;http.Server{
                Handler:           handler,
                ReadHeaderTimeout: time.Second * 5,
        }
        return cfg.ServeWith(ctx, srv, l)
}</span>

// ListenAndServe calls Listen followed by Serve.
func (cfg *Config) ListenAndServe(ctx context.Context, handler http.Handler) (err error) <span class="cov8" title="1">{
        if err = ctx.Err(); err == nil </span><span class="cov8" title="1">{
                var l net.Listener
                if l, err = cfg.Listen(); err == nil </span><span class="cov8" title="1">{
                        err = cfg.Serve(ctx, l, handler)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package webserv

import "fmt"

type errBecomeUser struct {
        userName string
        err      error
}

var ErrBecomeUser = errBecomeUser{}

func (e errBecomeUser) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("BecomeUser(\"%s\"): %v", e.userName, e.err)
}</span>

func (e errBecomeUser) Is(other error) (yes bool) <span class="cov8" title="1">{
        _, yes = other.(errBecomeUser)
        return
}</span>

func (e errBecomeUser) Unwrap() error <span class="cov8" title="1">{
        return e.err
}</span>

func newErrBecomeUser(userName string, err error) error <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                err = errBecomeUser{userName: userName, err: err}
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package webserv

import (
        "crypto/tls"
        "fmt"
        "net"
        "os"
        "strings"
)

const (
        FullchainPem = "fullchain.pem"
        PrivkeyPem   = "privkey.pem"
)

// Listener creates a net.Listener given an optional preferred address or port
// and an optional directory containing certificate files.
//
// If certDir is not empty, it calls LoadCert to load fullchain.pem and privkey.pem.
//
// The listener will default to all addresses and standard port
// depending on privileges and if a certificate was loaded or not.
//
// These defaults can be overridden with the listenAddr argument.
//
// Returns the net.Listener and listenURL if there was no error.
// If certificates were successfully loaded, absCertDir will be the absolute path to that directory.
func Listener(listenAddr, certDir, fullchainPem, privkeyPem, overrideUrl string) (l net.Listener, listenUrl, absCertDir string, err error) <span class="cov8" title="1">{
        var cert *tls.Certificate
        if cert, absCertDir, err = LoadCert(certDir, fullchainPem, privkeyPem); err == nil </span><span class="cov8" title="1">{
                var bindAddr string
                var schemesuffix string
                if cert != nil </span><span class="cov8" title="1">{
                        schemesuffix = "s"
                        if bindAddr, err = normalizeListenAddr(listenAddr, "443", "8443"); err == nil </span><span class="cov8" title="1">{
                                l, err = tls.Listen("tcp", bindAddr,
                                        &amp;tls.Config{
                                                Certificates: []tls.Certificate{*cert},
                                                MinVersion:   tls.VersionTLS13,
                                        },
                                )
                        }</span>
                } else<span class="cov8" title="1"> {
                        if bindAddr, err = normalizeListenAddr(listenAddr, "80", "8080"); err == nil </span><span class="cov8" title="1">{
                                l, err = net.Listen("tcp", bindAddr)
                        }</span>
                }
                <span class="cov8" title="1">if l != nil </span><span class="cov8" title="1">{
                        if listenUrl = overrideUrl; listenUrl == "" </span><span class="cov8" title="1">{
                                listenUrl = fmt.Sprintf("http%s://%s", schemesuffix, listenUrlString(l, cert))
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func normalizeListenAddr(address, defaultpriv, defaultother string) (result string, err error) <span class="cov8" title="1">{
        if _, _, err = net.SplitHostPort(address); err == nil </span><span class="cov8" title="1">{
                // host and port both present
                if strings.HasPrefix(address, "[]") </span><span class="cov8" title="1">{
                        err = net.InvalidAddrError(address)
                }</span> else<span class="cov8" title="1"> {
                        result = address
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">err = nil
        defaultPort := defaultpriv
        if os.Geteuid() &gt; 0 </span><span class="cov8" title="1">{
                defaultPort = defaultother
        }</span>

        <span class="cov8" title="1">result = address
        if strings.HasPrefix(address, "[") </span><span class="cov8" title="1">{
                if len(address) &gt; 2 &amp;&amp; strings.HasSuffix(address, "]") </span><span class="cov8" title="1">{
                        result = address[1 : len(address)-1]
                }</span> else<span class="cov8" title="1"> {
                        result = ""
                        err = net.InvalidAddrError(address)
                }</span>
        }
        <span class="cov8" title="1">result = net.JoinHostPort(result, defaultPort)
        return</span>
}

func localhostOrDNSName(cert *tls.Certificate) string <span class="cov8" title="1">{
        if cert != nil &amp;&amp; cert.Leaf != nil &amp;&amp; len(cert.Leaf.DNSNames) &gt; 0 </span><span class="cov8" title="1">{
                name := cert.Leaf.DNSNames[0]
                if host, _, err := net.SplitHostPort(name); err == nil </span><span class="cov8" title="1">{
                        name = host
                }</span>
                <span class="cov8" title="1">return name</span>
        }
        <span class="cov8" title="1">return "localhost"</span>
}

func listenUrlString(l net.Listener, cert *tls.Certificate) (addr string) <span class="cov8" title="1">{
        addr = l.Addr().String()
        if host, port, err := net.SplitHostPort(addr); err == nil </span><span class="cov8" title="1">{
                if ip := net.ParseIP(host); ip != nil </span><span class="cov8" title="1">{
                        if ip.IsUnspecified() || ip.IsLoopback() </span><span class="cov8" title="1">{
                                addr = net.JoinHostPort(localhostOrDNSName(cert), port)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package webserv

import (
        "crypto/tls"
        "os"
        "path/filepath"
)

// LoadCert does nothing if certDir is empty, otherwise it expands
// environment variables and transforms it into an absolute path.
// It then tries to load a X509 key pair from the files named fullchainPem
// and privkeyPem from the resulting directory.
//
// The filenames may contain paths, ".." segments and symlinks.
// They are not confined to certDir, so they may resolve outside of it.
// Caller is responsible for validating or sandboxing untrusted path input.
//
// If fullchainPem is empty, it defaults to "fullchain.pem".
// If privkeyPem is empty, it defaults to "privkey.pem".
//
// Return a non-nil cert and absolute path to certDir if there are no errors.
func LoadCert(certDir, fullchainPem, privkeyPem string) (cert *tls.Certificate, absCertDir string, err error) <span class="cov8" title="1">{
        if certDir != "" </span><span class="cov8" title="1">{
                certDir = os.ExpandEnv(certDir)
                if absCertDir, err = filepath.Abs(certDir); err == nil </span><span class="cov8" title="1">{
                        var cer tls.Certificate
                        if fullchainPem == "" </span><span class="cov8" title="1">{
                                fullchainPem = FullchainPem
                        }</span>
                        <span class="cov8" title="1">if privkeyPem == "" </span><span class="cov8" title="1">{
                                privkeyPem = PrivkeyPem
                        }</span>
                        <span class="cov8" title="1">fc := filepath.Join(absCertDir, fullchainPem)
                        pk := filepath.Join(absCertDir, privkeyPem)
                        if cer, err = tls.LoadX509KeyPair(fc, pk); err == nil </span><span class="cov8" title="1">{
                                cert = &amp;cer
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package webserv

import (
        "io/fs"
        "os"
        "path/filepath"
)

// DefaultDataDir returns the absolute path to dataDir if not empty, otherwise if
// defaultSuffix is not empty it returns the absolute joined path
// of os.UserConfigDir() and defaultSuffix.
//
// It will expand environment variables in the path before evaluating the
// absolute path.
//
// dataDir and defaultSuffix may contain paths, ".." segments and symlinks.
// They are not confined to UserConfigDir, so they may resolve outside of it.
// Caller is responsible for validating or sandboxing untrusted path input.
func DefaultDataDir(dataDir, defaultSuffix string) (result string, err error) <span class="cov8" title="1">{
        result = dataDir
        if result == "" </span><span class="cov8" title="1">{
                if defaultSuffix != "" </span><span class="cov8" title="1">{
                        if result, err = os.UserConfigDir(); err == nil </span><span class="cov8" title="1">{
                                result = filepath.Join(result, defaultSuffix)
                        }</span>
                }
        }
        <span class="cov8" title="1">if err == nil &amp;&amp; result != "" </span><span class="cov8" title="1">{
                result = os.ExpandEnv(result)
                result, err = filepath.Abs(result)
        }</span>
        <span class="cov8" title="1">return</span>
}

// UseDataDir transforms dataDir into an absolute path. Then, if mode
// is not zero, it creates the path if it does not exist. Does nothing
// if dataDir is empty. Does not expand environment variables in the path.
//
// Returns the final path or an empty string if dataDir was empty.
func UseDataDir(dataDir string, mode fs.FileMode) (string, error) <span class="cov8" title="1">{
        var err error
        if dataDir != "" </span><span class="cov8" title="1">{
                if dataDir, err = filepath.Abs(dataDir); err == nil </span><span class="cov8" title="1">{
                        if mode != 0 </span><span class="cov8" title="1">{
                                err = os.MkdirAll(dataDir, mode)
                        }</span>
                }
        }
        <span class="cov8" title="1">return dataDir, err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
